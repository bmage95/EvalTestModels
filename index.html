<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Model Eval</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #b0b0b0;
            min-height: 100vh;
            padding: 40px 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            color: white;
            font-size: 32px;
            font-weight: 300;
            letter-spacing: 1px;
        }

        .input-section {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-bottom: 40px;
        }

        .input-section input {
            width: 350px;
            padding: 12px 16px;
            border: none;
            border-radius: 0;
            font-size: 14px;
            background-color: white;
            font-family: inherit;
        }

        .input-section input:focus {
            outline: none;
            background-color: #f5f5f5;
        }

        .send-btn {
            background-color: #000;
            color: white;
            border: none;
            padding: 12px 28px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            font-family: inherit;
            letter-spacing: 0.5px;
            transition: background-color 0.2s;
        }

        .send-btn:hover {
            background-color: #222;
        }


        .metrics-section {
            display: flex;
            justify-content: center;
            gap: 80px;
            margin-bottom: 50px;
        }


        .metric {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .metric-label {
            color: white;
            font-size: 16px;
            font-weight: 300;
            letter-spacing: 0.5px;
        }

        .metric-value {
            background-color: #1a1a1a;
            color: white;
            padding: 6px 14px;
            font-size: 14px;
            font-weight: 500;
            border-radius: 2px;
            min-width: 45px;
            text-align: center;
            border: none;
            font-family: inherit;
            cursor: text;
        }

        .metric-value:focus {
            outline: none;
            background-color: #2a2a2a;
        }

        .dataset-section {
            display: none;
            margin-bottom: 50px;
            background-color: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-radius: 4px;
        }

        .model-selectors {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-bottom: 20px;
        }

        .model-select {
            background-color: rgba(0, 0, 0, 0.2);
            padding: 12px 16px;
            color: white;
            min-width: 220px;
        }

        .model-select label {
            display: block;
            font-size: 12px;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
            opacity: 0.8;
        }

        .model-select select {
            width: 100%;
            background-color: #1a1a1a;
            color: white;
            border: none;
            padding: 10px 12px;
            font-size: 14px;
        }

        .model-select select:hover {
            background-color: #2a2a2a;
        }

        .dataset-section.active {
            display: block;
        }

        .dataset-title {
            color: white;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 12px;
            letter-spacing: 0.5px;
            opacity: 0.9;
        }

        .test-case-select {
            background-color: #1a1a1a;
            color: white;
            padding: 8px 12px;
            border: none;
            border-radius: 2px;
            font-size: 14px;
            font-family: inherit;
            cursor: pointer;
            min-width: 300px;
        }

        .test-case-select:hover {
            background-color: #2a2a2a;
        }

        .test-case-info {
            color: white;
            font-size: 12px;
            margin-top: 8px;
            opacity: 0.8;
            max-width: 500px;
        }

        .metrics-section {
            display: flex;
            justify-content: center;
            gap: 80px;
            margin-bottom: 50px;
        }

        .model-card {
            text-align: center;
        }

        .model-name {
            color: white;
            font-size: 28px;
            font-weight: 300;
            margin-bottom: 20px;
            letter-spacing: 0.5px;
        }

        .answer-container {
            display: flex;
            gap: 20px;
            margin-bottom: 16px;
        }

        .answer-box {
            background-color: #000;
            color: white;
            padding: 40px 20px;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            line-height: 1.6;
            text-align: center;
            flex: 1;
        }

        .divider {
            width: 0.5px;
            background-color: white;
        }

        .eval-score {
            color: white;
            font-size: 16px;
            font-weight: 300;
            letter-spacing: 0.5px;
        }

        @media (max-width: 1024px) {
            .models-grid {
                grid-template-columns: 1fr;
            }

            .metrics-section {
                flex-direction: column;
                gap: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Model Eval</h1>
        </div>

        <div class="input-section">
            <input type="text" placeholder="" id="inputField">
            <button class="send-btn">send</button>
        </div>

        <div class="dataset-section" id="datasetSection">
            <div class="dataset-title">ðŸ“Š Load Test Case from Golden Dataset</div>
            <select class="test-case-select" id="testCaseSelect">
                <option value="">-- Select a test case --</option>
            </select>
            <div class="test-case-info" id="testCaseInfo"></div>
        </div>

        <div class="metrics-section">
            <div class="metric">
                <span class="metric-label">tool_trajectory_avg_score</span>
                <input type="number" step="0.1" min="0" max="1" class="metric-value" id="metric1" value="1.0" required>
            </div>
            <div class="metric">
                <span class="metric-label">response_match_score</span>
                <input type="number" step="0.1" min="0" max="1" class="metric-value" id="metric2" value="0.8" required>
            </div>
        </div>

        <div class="model-selectors">
            <div class="model-select">
                <label for="modelASelect">Model A</label>
                <select id="modelASelect"></select>
            </div>
            <div class="model-select">
                <label for="modelBSelect">Model B</label>
                <select id="modelBSelect"></select>
            </div>
            <div class="model-select">
                <label for="modelCSelect">Model C (Optional)</label>
                <select id="modelCSelect">
                    <option value="">-- None --</option>
                </select>
            </div>
        </div>

        <div class="models-grid">
            <div class="model-card">
                <h2 class="model-name" id="modelA-name">Model A</h2>
                <div class="answer-container">
                    <div class="answer-box" id="modelA-actual">
                        [ actual answer ]
                    </div>
                    <div class="divider"></div>
                    <div class="answer-box" id="modelA-expected">
                        [ expected answer ]
                    </div>
                </div>
                <p class="eval-score">Eval Score: <span id="modelA-pass">Pass</span> & <span id="modelA-threshold">Threshold</span></p>
            </div>

            <div class="model-card">
                <h2 class="model-name" id="modelB-name">Model B</h2>
                <div class="answer-container">
                    <div class="answer-box" id="modelB-actual">
                        [ actual answer ]
                    </div>
                    <div class="divider"></div>
                    <div class="answer-box" id="modelB-expected">
                        [ expected answer ]
                    </div>
                </div>
                <p class="eval-score">Eval Score: <span id="modelB-pass">Pass</span> & <span id="modelB-threshold">Threshold</span></p>
            </div>

            <div class="model-card" id="modelC-card" style="display:none;">
                <h2 class="model-name" id="modelC-name">Model C</h2>
                <div class="answer-container">
                    <div class="answer-box" id="modelC-actual">
                        [ actual answer ]
                    </div>
                    <div class="divider"></div>
                    <div class="answer-box" id="modelC-expected">
                        [ expected answer ]
                    </div>
                </div>
                <p class="eval-score">Eval Score: <span id="modelC-pass">Pass</span> & <span id="modelC-threshold">Threshold</span></p>
            </div>
        </div>
    </div>

    <script>
        const API_URL = 'http://localhost:5000/api';
        let expectedAnswer = '';
        let currentTestCase = null;
        let testCases = [];
        let availableGeminiModels = ['gemini-1.5-flash', 'gemini-1.5-flash-8b', 'gemini-1.5-pro', 'gemini-2.0-flash-exp', 'gemini-1.0-pro'];
        const selectedModels = {
            modelA: availableGeminiModels[0],
            modelB: availableGeminiModels[1] || availableGeminiModels[0],
            modelC: null
        };

        const getInputText = (tc) => (tc?.user_input || tc?.input || '').trim();
        const getExpectedText = (tc) => (tc?.expected_response || tc?.expected || '').trim();

        function updateModelLabels() {
            document.getElementById('modelA-name').textContent = selectedModels.modelA;
            document.getElementById('modelB-name').textContent = selectedModels.modelB;
            document.getElementById('modelC-name').textContent = selectedModels.modelC || 'Model C';
        }

        function resetCards() {
            ['modelA', 'modelB', 'modelC'].forEach(id => {
                document.getElementById(`${id}-expected`).textContent = '[ expected will appear after send ]';
                document.getElementById(`${id}-actual`).textContent = '[ waiting for response ]';
                document.getElementById(`${id}-pass`).textContent = 'Pass';
                document.getElementById(`${id}-threshold`).textContent = 'Threshold';
            });
        }

        function populateModelSelectors(models) {
            if (Array.isArray(models) && models.length) {
                availableGeminiModels = models;
            }

            const [first, second] = availableGeminiModels;
            if (!availableGeminiModels.includes(selectedModels.modelA)) {
                selectedModels.modelA = first;
            }
            if (!availableGeminiModels.includes(selectedModels.modelB)) {
                selectedModels.modelB = second || first;
            }
            if (selectedModels.modelC && !availableGeminiModels.includes(selectedModels.modelC)) {
                selectedModels.modelC = null;
            }

            const pairs = [
                { selectId: 'modelASelect', key: 'modelA' },
                { selectId: 'modelBSelect', key: 'modelB' },
                { selectId: 'modelCSelect', key: 'modelC' }
            ];

            pairs.forEach(({ selectId, key }) => {
                const select = document.getElementById(selectId);
                if (!select) return;
                
                // Model C has a "None" option
                if (key === 'modelC') {
                    select.innerHTML = '<option value="">-- None --</option>';
                } else {
                    select.innerHTML = '';
                }
                
                availableGeminiModels.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    select.appendChild(option);
                });
                
                select.value = selectedModels[key] || '';
                
                select.addEventListener('change', (e) => {
                    selectedModels[key] = e.target.value || null;
                    
                    // Show/hide Model C card
                    if (key === 'modelC') {
                        const card = document.getElementById('modelC-card');
                        if (selectedModels.modelC) {
                            card.style.display = 'block';
                        } else {
                            card.style.display = 'none';
                        }
                    }
                    
                    updateModelLabels();
                    resetCards();
                });
            });

            updateModelLabels();
            
            // Initially hide Model C if not selected
            if (!selectedModels.modelC) {
                document.getElementById('modelC-card').style.display = 'none';
            }
        }

        // Check backend health and load golden dataset
        window.addEventListener('load', async () => {
            try {
                const response = await fetch(`${API_URL}/health`);
                const data = await response.json();
                console.log('Backend Status:', data);
                populateModelSelectors(data.gemini_default_models);
                
                if (!data.ollama_available) {
                    console.warn('âš ï¸ Ollama not available. Install from https://ollama.ai');
                }
                
                // Load golden dataset test cases
                if (data.dataset_loaded) {
                    loadTestCases();
                }
            } catch (error) {
                console.error('Backend not reachable. Make sure to run: python app.py', error);
                populateModelSelectors();
            }
        });

        // Load test cases from golden dataset
        async function loadTestCases() {
            try {
                const response = await fetch(`${API_URL}/dataset/test-cases`);
                const data = await response.json();
                
                testCases = data.cases || [];
                console.log(`Loaded ${testCases.length} test cases from golden dataset`);
                
                // Show dataset section
                document.getElementById('datasetSection').classList.add('active');
                
                // Populate dropdown
                const select = document.getElementById('testCaseSelect');
                testCases.forEach(tc => {
                    const option = document.createElement('option');
                    option.value = tc.eval_id;
                    option.textContent = `${tc.eval_id.substring(0, 8)}... - "${tc.user_input.substring(0, 40)}..."`;
                    select.appendChild(option);
                });
                
                // Handle selection
                select.addEventListener('change', selectTestCase);
            } catch (error) {
                console.warn('Could not load test cases:', error);
            }
        }

        // Select a test case from dropdown
        function selectTestCase(e) {
            const eval_id = e.target.value;
            if (!eval_id) return;
            
            currentTestCase = testCases.find(tc => tc.eval_id === eval_id);
            if (!currentTestCase) return;
            
            // Store but don't show expected yet - will show after clicking send
            expectedAnswer = '';
            
            // Show test case info (without revealing expected)
            const info = document.getElementById('testCaseInfo');
            info.innerHTML = `
                <strong>Test Input:</strong> ${getInputText(currentTestCase)}<br>
                <strong>Status:</strong> Ready to evaluate - click Send
            `;
            
            resetCards();
            
            // Auto-fill input field with test case input
            document.getElementById('inputField').value = getInputText(currentTestCase);
            
            console.log('Test case selected:', currentTestCase.eval_id);
        }

        // Send button functionality
        document.querySelector('.send-btn').addEventListener('click', async function() {
            const input = document.getElementById('inputField');
            const value = input.value.trim();
            
            if (!value) {
                alert('Please enter a prompt or select a test case');
                return;
            }

            // Clear input
            input.value = '';

            // Reset expected box until we set it
            resetCards();

            // Ask backend to find golden case by input (trim/case-insensitive)
            const matched = await lookupGoldenByInput(value);
            if (matched && matched.found && matched.case) {
                expectedAnswer = matched.expected || '';
                currentTestCase = {
                    eval_id: matched.case.eval_id,
                    user_input: matched.case.user_input,
                    expected_response: matched.expected
                };

                document.getElementById('testCaseSelect').value = matched.case.eval_id;
                document.getElementById('testCaseInfo').innerHTML = `
                    <strong>Test Input:</strong> ${matched.case.user_input}<br>
                    <strong>Source:</strong> Golden Dataset (${matched.case.eval_id.substring(0, 8)}...)
                `;
                console.log('âœ“ Using golden dataset expected for:', matched.case.eval_id);
            } else {
                // Not a golden match: generate expected answer via Gemini
                expectedAnswer = await generateExpectedAnswer(value);
                if (!expectedAnswer) {
                    expectedAnswer = '[expected not available]';
                }
                currentTestCase = null;
                
                document.getElementById('testCaseSelect').value = '';
                document.getElementById('testCaseInfo').innerHTML = `
                    <strong>Test Input:</strong> ${value}<br>
                    <strong>Source:</strong> Generated Expected (not in golden dataset)
                `;
                console.log('âœ“ Generated expected answer via Gemini');
            }

            // Show expected in UI
            document.getElementById('modelA-expected').textContent = expectedAnswer;
            document.getElementById('modelB-expected').textContent = expectedAnswer;
            if (selectedModels.modelC) {
                document.getElementById('modelC-expected').textContent = expectedAnswer;
            }

            // Generate model answers
            await generateAnswers(value);
            
            // Evaluate with LLaMA judge
            await evaluateAllModels();
        });

        // Allow Enter key to send
        document.getElementById('inputField').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                document.querySelector('.send-btn').click();
            }
        });

        async function evaluateModel(modelType) {
            const passSpan = document.getElementById(`${modelType}-pass`);
            const thresholdSpan = document.getElementById(`${modelType}-threshold`);
            const actualEl = document.getElementById(`${modelType}-actual`);
            const modelName = selectedModels[modelType] || modelType;

            const actualAnswer = actualEl.textContent.trim();
            if (!actualAnswer || actualAnswer.startsWith('[ waiting') || actualAnswer.startsWith('[error')) {
                return; // skip empty
            }
            if (!expectedAnswer) {
                alert('Please set expected answer first');
                return;
            }

            passSpan.textContent = 'Evaluating...';
            thresholdSpan.textContent = 'Evaluating...';

            try {
                const judgeModel = 'llama70b';
                const response = await fetch(`${API_URL}/evaluate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        actual_answer: actualAnswer,
                        expected_answer: expectedAnswer,
                        judge_model: judgeModel
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Evaluation failed');
                }

                const result = await response.json();

                const passScore = Number(result.pass_score ?? 0);
                const threshScore = Number(result.threshold_score ?? 0);
                // Pass/Fail per criteria: both metrics must meet their thresholds
                const trajThreshold = Number(document.getElementById('metric1').value || 0); // tool_trajectory_avg_score
                const respThreshold = Number(document.getElementById('metric2').value || 0); // response_match_score
                const passed = passScore >= trajThreshold && threshScore >= respThreshold;

                passSpan.textContent = passed ? `PASS (${passScore.toFixed(2)})(user intent)` : `FAIL (${passScore.toFixed(2)})(user intent)`;
                thresholdSpan.textContent = `quality/similarity score: ${threshScore.toFixed(2)}`;
                console.log(`${modelName} evaluation:`, result);

            } catch (error) {
                console.error('Evaluation error:', error);
                passSpan.textContent = 'Error';
                thresholdSpan.textContent = 'Error';
                alert(`Evaluation failed: ${error.message}`);
            }
        }

        async function generateAnswers(promptText) {
            if (!promptText) return;

            const models = [selectedModels.modelA, selectedModels.modelB];
            const cardOrder = ['modelA', 'modelB'];
            
            if (selectedModels.modelC) {
                models.push(selectedModels.modelC);
                cardOrder.push('modelC');
            }
            
            cardOrder.forEach(cardId => {
                const el = document.getElementById(`${cardId}-actual`);
                el.textContent = '[ generating answer... ]';
            });

            try {
                const response = await fetch(`${API_URL}/generate-answers`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        input: promptText,
                        eval_id: currentTestCase?.eval_id || null,
                        models
                    })
                });

                const data = await response.json();
                if (!response.ok) {
                    throw new Error(data.error || 'Generation failed');
                }

                const answers = data.answers || {};
                cardOrder.forEach((cardId, idx) => {
                    const modelKey = models[idx];
                    const el = document.getElementById(`${cardId}-actual`);
                    const payload = answers[modelKey] || {};
                    if (payload.text) {
                        el.textContent = payload.text;
                    } else if (payload.error) {
                        el.textContent = `[error: ${payload.error}]`;
                    } else {
                        el.textContent = '[ no answer returned ]';
                    }
                });
                console.log('Generated answers:', answers);
            } catch (error) {
                console.error('Generation error:', error);
                cardOrder.forEach(cardId => {
                    const el = document.getElementById(`${cardId}-actual`);
                    el.textContent = `[error: ${error.message}]`;
                });
            }
        }

        async function generateExpectedAnswer(promptText) {
            if (!promptText) return '';
            try {
                const response = await fetch(`${API_URL}/generate-expected`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ input: promptText })
                });
                const data = await response.json();
                if (!response.ok) {
                    throw new Error(data.error || 'Expected generation failed');
                }
                return data.expected || '';
            } catch (error) {
                console.error('Expected generation error:', error);
                return '';
            }
        }

        async function lookupGoldenByInput(promptText) {
            try {
                const response = await fetch(`${API_URL}/dataset/find-by-input`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ input: promptText })
                });
                if (response.status === 404) return null;
                const data = await response.json();
                if (!response.ok) throw new Error(data.error || 'lookup failed');
                return data;
            } catch (err) {
                console.warn('Lookup error:', err.message);
                return null;
            }
        }

        async function evaluateAllModels() {
            await evaluateModel('modelA');
            await evaluateModel('modelB');
            if (selectedModels.modelC) {
                await evaluateModel('modelC');
            }
        }

        // Evaluate on clicking any actual box
        document.addEventListener('click', async function(e) {
            if (e.target.classList.contains('answer-box') && e.target.id && e.target.id.endsWith('-actual')) {
                const modelType = e.target.id.split('-')[0];
                await evaluateModel(modelType);
            }
        });

        // Optionally auto-evaluate when expectedAnswer changes and actuals exist
        async function maybeAutoEvaluate() {
            if (expectedAnswer) {
                await evaluateAllModels();
            }
        }

        // Allow editing answer boxes (click to input)
        const answerBoxes = document.querySelectorAll('.answer-box');
        answerBoxes.forEach(box => {
            box.contentEditable = 'true';
            box.addEventListener('blur', function() {
                // Save content
                console.log(`${this.id} updated:`, this.textContent);
            });
        });
    </script>
</body>
</html>